[{"content":"問題 事情是怎麼發生的呢? 且聽我娓娓道來\u0026hellip;\u0026hellip;\n當時我就想，為了確保每個屬性的獨特性，我做了這件事\n1 2 3 4 5 6 7 8 9 let fruit = { \u0026#39;Apple\u0026#39;: Symbol(\u0026#39;Apple\u0026#39;), \u0026#39;Grape\u0026#39;: Symbol(\u0026#39;Grape\u0026#39;), }; let products = { [fruit.Apple]: [\u0026#39;Apple Juice\u0026#39;, \u0026#39;Apple Pie\u0026#39;], [fruit.Grape]: [\u0026#39;Grape Juice\u0026#39;, \u0026#39;Grape Jam\u0026#39;], }; 目前為止都很正常，直到\u0026hellip;\n直到我想在每個水果中加個Color屬性\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 let fruit = { \u0026#39;Apple\u0026#39;: { symbol: Symbol(\u0026#39;Apple\u0026#39;), color: \u0026#39;Red\u0026#39;, }, \u0026#39;Grape\u0026#39;: { symbol: Symbol(\u0026#39;Grape\u0026#39;), color: \u0026#39;Green\u0026#39;, }, }; 然後products、products他！\n他就、就只剩下一個屬性了！？\n解析 為了解釋發生了甚麼，來做幾個測試：\nKey的類型 何種類型會造成這種結果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 console.log(typeof Object.keys(products)[0]); let keyObj1 = { a: 1 }; let keyObj2 = { a: 1 }; let keyArr1 = [1]; let keyArr2 = [1]; let obj = { [keyObj1]: 1, [keyArr1]: 2, [keyObj2]: 3, [keyArr2]: 4, }; console.log(obj); 結果：\n1 2 string { \u0026#39;1\u0026#39;: 4, \u0026#39;[object Object]\u0026#39;: 3 } 原來，js在創建物件時，會把輸入值轉成字串\n然而Symbol是個例外，也就是說，js物件的鍵值可以是Symbol/String\n所以才有剛剛那種慘案發生\n解方 Map Map應該會是最佳選擇，Map的Key可以是任何類型\n還有Map比起Object，Map中的Key-Value Pair是有順序的，不像Object是無序\n1 2 3 4 5 6 7 8 9 let map = new Map(); map.set(keyObj1, 1); map.set(keyArr1, 2); map.set(keyObj2, 3); map.set(keyArr2, 4); for (let item of map) { console.log(item); } 1 2 3 4 [ { a: 1 }, 1 ] [ [ 1 ], 2 ] [ { a: 1 }, 3 ] [ [ 1 ], 4 ] WeakMap WeakMap就比較玄了\n他的Key只能是Object，當然null不行\n再來他是弱引用，甚麼意思呢?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let obj1 = { a: { a1: 1, } }; let weakmap = new WeakMap(); weakmap.set(\u0026#39;123\u0026#39;, \u0026#39;123\u0026#39;); // TypeError: Invalid value used as weak map key weakmap.set(obj1.a, \u0026#39;obj1.a\u0026#39;); console.log(weakmap.has(obj1.a)); console.log(weakmap.get(obj1.a)); delete obj1.a; console.log(weakmap.has(obj1.a)); console.log(weakmap.get(obj1.a)); 1 2 3 4 true obj1.a false undefined 就是當一個Key被刪除或是被回收時，WeakMap中的Key-Value Pair也會同時消失\n可以防止內存洩漏的問題\n還有，WeakMap是看不到Key List的，所以他的Key List會取決於Key存不存在\n所以當Key被Garbage Collection回收時，對應的Value會消失\n比較多會用在DOM的處理，DOM元素消失後，Value也消失了||拉人下水||\n題外話：\n我個人覺得應該叫強引用而不是弱\n因為WeakMap實際上加強了對Key的連結\n叫弱引用\u0026hellip;想不太通\n","date":"2023-04-16T18:04:10+08:00","permalink":"https://chaoray.github.io/p/js%E7%94%A8%E7%89%A9%E4%BB%B6%E7%95%B6%E9%8D%B5%E5%80%BC/","title":"JS用物件當鍵值"},{"content":"自從JS推出Class之後，我就覺得他好原始(x\n說真的，JS裡面的Class真的不成熟，很多東西都沒有\n甚麼public、private、override、virtual\n雖說TS都有，但有些情況下TS開發是災難\n寫起JS的物件導向會掉根頭髮\n寫法 靜態 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Skill { name; use() {} } class Character { skill = new Skill(); } class Adventurer extends Character { static AdventurerSkill = class extends Skill { name = \u0026#34;Healing\u0026#34;; use() { console.log(\u0026#34;HP+100\u0026#34;); } } skill = new Adventurer.AdventurerSkill(); } 動態 1 2 3 4 5 6 7 8 9 10 11 12 13 class Magician extends Character { MagicianSkill; constructor() { this.MagicianSkill = class extends Skill { name = \u0026#34;Strengthening\u0026#34;; use() { console.log(\u0026#34;ATK+100\u0026#34;); } } this.skill = new this.MagicianSkill(); } } 個人覺得這種寫法很酷，而且可以提高通用性，到時候只要統一呼叫\n1 character.skill.use(); 有趣的是，當VSCode在推斷型別的時候： ","date":"2023-04-02T00:04:03+08:00","image":"https://chaoray.github.io/p/js%E4%B8%AD%E7%9A%84%E5%B7%A2%E7%8B%80class/cover_hu8c7fd172fb3edf68f8584e0253482f85_4423_120x120_fill_box_smart1_3.png","permalink":"https://chaoray.github.io/p/js%E4%B8%AD%E7%9A%84%E5%B7%A2%E7%8B%80class/","title":"JS中的巢狀Class"},{"content":"準備環境 安裝C++編譯器 關於安裝編譯器的問題之前已經有文章說過了\n傳送門🚪：在Windows安裝C/C++ Compiler\n疑難排解\nQ: 裝錯了或想換版本該如何解安裝？\n把-S參數換成-R即可\nEx: pacman -S mingw-w64-ucrt-x86_64-gcc -\u0026gt; pacman -R mingw-w64-ucrt-x86_64-gcc\nQ: 裝了C++之後還要裝C嗎?\n不用，會同時安裝g++跟gcc，前者是編譯C++的，後者是編譯C的\n另外請不要拿gcc去編譯C++，會有意想不到的錯誤\n也不要拿g++去編譯C，我知道你想這麼做，但是不行\n安裝VSCode VSCode載點：VSCode - Code editing. Redefined.\n按鈕很大很顯眼，沒看見我建議你去看醫生\n接下來的步驟就是下一步式點選，不會的我建議你，||算了你大概也聽不懂||\n在安裝過程中有兩個選項大力推薦勾選：\n為甚麼？||問那麼多幹嘛做就對了||\n這樣可以省去很多不必要的動作，一般來說，想要在VSCode中開啟檔案或資料夾\n沒勾選之前的動作都是：\n開VSCode 把檔案拖到VSCode視窗中 但是勾選之後可以變成：\n檔案/資料夾右鍵\n老實講省很多時間，所以還不勾\n安裝擴充套件 如果只是要寫C/C++的話，安裝這個就完全ok了\nC/C++ Extension Pack\n裝好之後，以防萬一重新開啟VSCode\n組態設定 之後按F1，打入：\n1 C/C++: Edit Configurations UI 視窗正中央會出現一個選項\n再來會跳出的視窗，這裡是C/C++編譯、語法的一些設定\n編譯器路徑 首先是編譯器路徑，右邊下拉選單應該會有不同種選擇\n如果一個都沒看到，很大概率是你的系統路徑設定錯誤，可以回去檢視有沒有每項都做到\n傳送門🚪：在Windows安裝C/C++ Compiler - 重點：加入系統路徑\n編譯C，選擇gcc.exe 編譯C++，選擇g++.exe 這裡講一下畫面中gcc.exe、g++.ex、cpp.exe的不同：\ngcc.exe：編譯C語言，處理.c結尾的檔案 g++.exe：編譯C++語言，處理.cpp結尾的檔案 cpp.exe：處理宏(macros)，擔任前置處理器(preprocessor)的角色 點選正確的編譯器之後，才不會出現一堆錯誤\nIntellisense 模式 甚麼是Intellisense(智能感知)？\n簡單來說，就是讓你寫程式不用那麼累 很多時候我們會用到來自其他函式庫的東西，這時候如果要去尋找這個函式該怎麼使用\n就要一層一層點點點，點到函式宣告的地方，才能真正知道\n有Intellisense之後，IDE就會自動幫我們去完成這件事\n或是在語法上提供一些指引，讓我們寫Code出錯機率不那麼高\n以下是一些Intellisense的實際作用： ||所以你們還不趕快拜Intellisense||\nIntellisense的模式就很多樣化了\n可以使用下列填空題來找到該選哪個\n[系統平台]-[編譯器版本]-[系統架構]\n以我用Windows x64 Bit，安裝GCC舉例，就要選\nwindows-gcc-x64\n用MACOS Arm64，安裝CLANG，就要選\nmacos-clang-arm64\n後面的新手盡量不要去動，不然出錯了很難找到原因\n編譯 都設定好後，回到程式碼檔案，按下Ctrl+Shift+B應該會出現\n這時候不要著急點，你應該點的是旁邊的齒輪 會多出一個名為tasks.json的檔案 這時候再按一次Ctrl+Shift+B，就可以成功編譯\n1 2 3 4 5 6 7 * 正在執行的工作: C/C++: g++.exe 建置使用中檔案 正在開始建置... C:\\msys64\\ucrt64\\bin\\g++.exe -fdiagnostics-color=always -g C:\\...\\main.cpp -o C:\\...\\main.exe 已成功完成建置。 * 工作將被重新啟用.按任意鍵關閉. 程式碼下方會多出一個跟檔案同名的exe檔，按Ctrl+Shift+~(ESC下方那顆)\n我的cpp檔案叫main.cpp，編譯之後會有main.exe\n在終端打上main.exe，按下TAB\n按ENTER就能看到執行結果！\n1 2 3 PS C:\\...\\test\u0026gt; .\\main.exe Hello world PS C:\\...\\test\u0026gt; ","date":"2023-04-01T19:47:34+08:00","permalink":"https://chaoray.github.io/p/%E5%9C%A8vscode%E4%B8%8A%E9%96%8B%E7%99%BCc-/","title":"在VSCode上開發C++"},{"content":"最近遇到一個問題：Cors (Cross-Origin Resource Sharing)\n在瀏覽器中開Live-server，fetch其他網域的網站，會跳除如下錯誤\n1 2 3 Access to fetch at \u0026#39;https://example.com/\u0026#39; from origin \u0026#39;http://127.0.0.1:8080\u0026#39; has been blocked by CORS policy: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. If an opaque response serves your needs, set the request\u0026#39;s mode to \u0026#39;no-cors\u0026#39; to fetch the resource with CORS disabled. 被最後一句話騙，乖乖加上no-cors後，response是空的\u0026hellip;.\n其實這是瀏覽器內部的限制，為了資安疑慮所設的\n目前有兩種主要解決辦法：\n跟伺服器管理員溝通，讓他在response的header中加上Access-Control-Allow-Origin 架個proxy，回傳時header加上Access-Control-Allow-Origin 已經有人寫好proxy了，隨便找個託管(render、heroku)都可以架\n連結：Rob\u0026ndash;W/cors-anywhere\n雖然說CORS對網頁開發者是惡夢，不過確實達到安全的目的\n早有耳聞，但是第一次自己遇到還是很新鮮 (汗\n","date":"2023-03-18T15:50:37+08:00","image":"https://chaoray.github.io/p/%E8%B7%A8%E5%9F%9F%E8%AB%8B%E6%B1%82%E9%99%90%E5%88%B6%E5%95%8F%E9%A1%8C/cred-req-updated_hu25a6c481aa7bcbf69edaee2bc4b1b897_15187_120x120_fill_box_smart1_3.png","permalink":"https://chaoray.github.io/p/%E8%B7%A8%E5%9F%9F%E8%AB%8B%E6%B1%82%E9%99%90%E5%88%B6%E5%95%8F%E9%A1%8C/","title":"跨域請求限制問題"},{"content":"最近剛好比較有機會碰OOP，想寫個thread卻噴一堆錯誤🙄\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Example { private: thread t1; void worker() { for (int i = 0; i \u0026lt; 10000000; i++) { printf(\u0026#34;%d\u0026#34;, i); } } public: Example() { t1 = std::thread(worker); } }; 編譯之後悲劇：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 In file included from C:/msys64/ucrt64/include/c++/12.2.0/thread:43, from C:\\Users\\...\\test.cpp:2: C:/msys64/ucrt64/include/c++/12.2.0/bits/std_thread.h: In instantiation of \u0026#39;std::thread::thread(_Callable\u0026amp;\u0026amp;, _Args\u0026amp;\u0026amp; ...) [with _Callable = void (Example::*)(); _Args = {}; \u0026lt;template-parameter-1-3\u0026gt; = void]\u0026#39;: C:\\Users\\...\\test.cpp:17:32: required from here C:/msys64/ucrt64/include/c++/12.2.0/bits/std_thread.h:129:72: error: static assertion failed: std::thread arguments must be invocable after conversion to rvalues 129 | typename decay\u0026lt;_Args\u0026gt;::type...\u0026gt;::value, | ^~~~~ C:/msys64/ucrt64/include/c++/12.2.0/bits/std_thread.h:129:72: note: \u0026#39;std::integral_constant\u0026lt;bool, false\u0026gt;::value\u0026#39; evaluates to false C:/msys64/ucrt64/include/c++/12.2.0/bits/std_thread.h: In instantiation of \u0026#39;struct std::thread::_Invoker\u0026lt;std::tuple\u0026lt;void (Example::*)()\u0026gt; \u0026gt;\u0026#39;: C:/msys64/ucrt64/include/c++/12.2.0/bits/std_thread.h:202:13: required from \u0026#39;struct std::thread::_State_impl\u0026lt;std::thread::_Invoker\u0026lt;std::tuple\u0026lt;void (Example::*)()\u0026gt; \u0026gt; \u0026gt;\u0026#39; C:/msys64/ucrt64/include/c++/12.2.0/bits/std_thread.h:142:29: required from \u0026#39;std::thread::thread(_Callable\u0026amp;\u0026amp;, _Args\u0026amp;\u0026amp; ...) [with _Callable = void (Example::*)(); _Args = {}; \u0026lt;template-parameter-1-3\u0026gt; = void]\u0026#39; C:\\Users\\...\\test.cpp:17:32: required from here C:/msys64/ucrt64/include/c++/12.2.0/bits/std_thread.h:251:11: error: no type named \u0026#39;type\u0026#39; in \u0026#39;struct std::thread::_Invoker\u0026lt;std::tuple\u0026lt;void (Example::*)()\u0026gt; \u0026gt;::__result\u0026lt;std::tuple\u0026lt;void (Example::*)()\u0026gt; \u0026gt;\u0026#39; 251 | _M_invoke(_Index_tuple\u0026lt;_Ind...\u0026gt;) | ^~~~~~~~~ C:/msys64/ucrt64/include/c++/12.2.0/bits/std_thread.h:255:9: error: no type named \u0026#39;type\u0026#39; in \u0026#39;struct std::thread::_Invoker\u0026lt;std::tuple\u0026lt;void (Example::*)()\u0026gt; \u0026gt;::__result\u0026lt;std::tuple\u0026lt;void (Example::*)()\u0026gt; \u0026gt;\u0026#39; 255 | operator()() | ^~~~~~~~ std系列還真是讓人難以捉摸，把比較像錯誤的訊息找找看：\n1 error: static assertion failed: std::thread arguments must be invocable after conversion to rvalues 結果都跟我說是參數傳遞問題\u0026hellip;\n可是我沒有傳遞參數？\n1 2 void worker(); t1 = std::thread(worker); 連回傳值都是void，這該怎麼辦？\n想到它是在Class裡發生的，改變一下關鍵字\n解答：Start thread with member function\n這樣就可以了\n1 t1 = std::thread(\u0026amp;Example::worker, this); 繼續Coding~\n","date":"2023-03-13T22:07:54+08:00","image":"https://chaoray.github.io/p/stdthread-%E4%BD%BF%E7%94%A8%E9%A1%9E%E5%88%A5%E6%88%90%E5%93%A1%E5%87%BD%E5%BC%8F/_hu5fce2522ed51544b0a523eedb70d2a1f_1758880_de022777f43de7af1dc8a9ca91b7777a.jpg","permalink":"https://chaoray.github.io/p/stdthread-%E4%BD%BF%E7%94%A8%E9%A1%9E%E5%88%A5%E6%88%90%E5%93%A1%E5%87%BD%E5%BC%8F/","title":"std::thread 使用類別成員函式"},{"content":"怎麼開始？ 不管甚麼原因致使你踏入這個領域，如果你不是非自願、沒有熱誠，我肯定你沒辦法在這條路上走下去\n只要你有一台能跑的電腦、能正常運作的編輯器，那很好，你已經開始一半了\n是甚麼念頭讓你對程式感興趣呢，就朝那個方向邁進吧\n善用網路 應該都聽過一句話：「You know google? You can google.」\n對，遇到不懂的，不管三七二十一直接丟上google就對了\n不懂的英文？可以翻譯\n在你未來繼續走下去的路上，網路絕對是你最好的夥伴\n假如我在一篇文章裡看到：「Currying」\n我唯一確定的是他跟程式有關\n丟上Google一查\n「Currying 程式」\n原來是柯里化||還想說是咖哩或是某個知名球星||\n然後，順著Currying這個名詞，我又額外查了很多名詞、找了很多資料，了解柯里化到底是甚麼\n這樣又學到了很多東西\n學甚麼語言？ 一個語言，在你對程式有點小懂開始，其實就會發現，等同於工具\n需要，用的到，所以學，所以寫\n對初學者來說，從簡單的語言開始絕對是康莊大道\n常見的有：Python、Java、JavaScript、HTML/CSS\nP.S.：如果不知道這是甚麼，請右轉Google\n如果你想問的是：這麼多選擇中，我該學哪一種會比較有幫助、比較好找工作？\n你看哪個順眼就學吧，不然靠抽籤也是可以的\n程式語言就像是方言，雖然聽起來很不一樣，但是同樣的概念會一再重複\n只要你能使用一個程式語言，那其他的對你來講只是轉個彎而已\n不過還是有特例啦，像COBOL、ASM ||上古時期的東西||\n如果你的學校還在教C、Scratch，我建議你直接自學\n好的習慣 很多習慣會影響你後來寫程式的好壞，只要習慣了，絕對不一樣\n好的命名 有天小明他爸透過聊天軟體問小明要吃甚麼，小明敲不定主意\n回了句：「IDK」\n小明他爸直接恍然大悟\nIDK是甚麼？是某種食物嗎？還是哪家店？還是罵人的話？||怎麼辦我是不是被他討厭了||\n於是接下來的時間小明爸沒再跟小明講過話 (x\n所以說，縮寫很容易造成誤會\n請參考以下事項：\nReminds me of a post I read on either reddit or quora about a guy who read some old code of his and noticed there was a variable oddly named \u0026ldquo;feet\u0026rdquo;, then decided to investigate why this was and found out that, due to abbreviation, the original name \u0026ldquo;legacyHandles\u0026rdquo; came to be \u0026ldquo;legHands\u0026rdquo; which then ended up as \u0026ldquo;feet\u0026rdquo;.\n簡單翻譯一下，就是有人把一個原本跟\u0026quot;腳\u0026quot;搭不上邊的變數名稱，硬生生地變成了\u0026quot;腿的手\u0026quot;，也就是\u0026quot;腳\u0026quot;\n縮寫就是斷章取義，就算只有一點縮寫也可能會讓後來看你的程式碼的人誤解\n但其實有些縮寫可以，就是約定俗成，而且實在是太常用了\n1 2 3 4 5 6 7 8 9 10 11 string -\u0026gt; str object -\u0026gt; obj array -\u0026gt; arr error -\u0026gt; err length -\u0026gt; len message -\u0026gt; msg number -\u0026gt; num position -\u0026gt; pos address -\u0026gt; addr temporary -\u0026gt; tmp argument -\u0026gt; arg 可以去看看別人整理的：编程常用缩写 by bill_20106029\n通常來說，主流有兩種變數名稱寫法：\n駝峰命名法(Camel Case)：將每個單詞的開頭大寫 蛇形命名法(Snake Case)：將每個單詞小寫後以底線分開 1 2 3 4 5 6 // 駝峰 camelCase CamelCase // 蛇形 snake_case 比較古早味的Code或工程師，很常會看到匈牙利命名法\n1 2 3 4 float fPrice = 10.0f; int iCount = 10; bool bBusy = false; float* fpPrice = \u0026amp;fPrice; // float point 也就是將變數型別納入變數名稱中，不過現在IDE很強大，根本不需要你做這種事\n一些我常用的命名規則：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 布林值：用Yes/No問句命名 bool isBusy, canBeDestroyed; // 或者有些語言支援問號在變數裡 bool isOverlapped?, isArrayEmpty?; // 常數：全大寫 int WINDOW_HEIGHT = 100; // 函數：以動詞開頭 long createTimestamp(); bool checkIsClientReady(); // 類別：開頭全大寫 class FireMagician; class JavascriptLanguageCompiler; 選擇自己看起來舒服就好，記住，不要縮寫!!!，就算變數名稱再長，寫就對了!\n1 int i_have_no_idea_what_this_variable_should_be_called_but_anyway_i_named_it; 限制參數傳入量 今天有個這樣的函式：\n1 function createUserAccountInfo(name, address, birthday, age, email, phoneNumber, fbName, igId) 你在用的時候\n1 createUserAccountInfo(\u0026#34;John\u0026#34;, \u0026#34;my-email@mail.com\u0026#34;, ); 阿，好像信箱地址不是擺這的，回去看看\u0026hellip;\u0026hellip;原來前面要先填地址\n1 createUserAccountInfo(\u0026#34;John\u0026#34;, \u0026#34;ThisCity-ThatTown-ThatRoad\u0026#34;, \u0026#34;my-email@mail.com\u0026#34;, \u0026#34;0912345678\u0026#34;); 奇怪，IDE跳錯誤，怎麼要填整數，回去看看\u0026hellip;\u0026hellip;是要填年齡阿\n1 createUserAccountInfo(\u0026#34;John\u0026#34;, \u0026#34;ThisCity-ThatTown-ThatRoad\u0026#34;, \u0026#34;my-email@mail.com\u0026#34;, 23, \u0026#34;0912345678\u0026#34;, \u0026#34;2000-1-1\u0026#34;, \u0026#34;i_am_john\u0026#34;, \u0026#34;john987123\u0026#34;); 當你以為一切安好，跑跑看的時候\u0026hellip;\n整個就是大災難\n原本該填生日的地方變成了信箱\n該填電話號碼的地方變成了生日\n肯定當場氣到哭\n通常，如果超過三個變數，就建議拆成兩個以上函式\n以剛剛的createUserAccountInfo舉例：\n1 2 3 4 5 function createUserAccountInfo(birthInfo, contactInfo, socialMediaInfo) function createAccountBirthInfo(birthday, age) function createAccountContactInfo(address, email, phoneNumber) function createAccountSocialMediaInfo(fbName, igId) 清爽多了，而且哪個函式有問題基本上都可以直接抓出來修\n如果你真的要用到更多的變數，那請考慮將它們包成一個物件：\n1 2 3 4 5 6 7 8 9 10 let AccountInfo = { name: \u0026#34;\u0026#34;, address: \u0026#34;\u0026#34;, birthday: \u0026#34;\u0026#34;, age: 0, email: \u0026#34;\u0026#34;, phoneNumber: \u0026#34;\u0026#34;, fbName: \u0026#34;\u0026#34;, igId: \u0026#34;\u0026#34; }; 一個函式，做一件事 又叫單一職責原則，簡單來說就是，做函式名稱做的事，但只有一件事\n考慮以下函式：\n1 2 3 4 5 6 function createUserAccountInfo(accountInfo) { let info = new UserAccountInfo(accountInfo); sendInfo(info); info.balance = 0; return info; } 怎麼突然就跑去寄資料了？為甚麼又設定餘額為0？\n然後過沒幾天你就會在後台發現不知為何多了很多筆使用者資料\u0026hellip;\n那麼要如實寫出函式做了甚麼：\n1 2 3 4 5 6 function createUserAccountInfoAndSendInfoAndSetBalanceTo0(accountInfo) { let info = new UserAccountInfo(accountInfo); sendInfo(info); info.balance = 0; return info; } 很肯定的，沒有人知道我到底在寫甚麼，我也不知道\n就算如實寫出來，那也違反了只做一件事\n所以可以拆成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function registerUserAccount(infoObj) { let info = createUserAccountInfo(infoObj); info = initUserAccountInfo(info); if (sendUserAccountInfo(info)) { return info; } else { throw new Error(\u0026#34;Could not send user account\u0026#34;); } } function createUserAccountInfo(accountInfo) { let info = new UserAccountInfo(accountInfo); return info; } function sendUserAccountInfo(accountInfo) { let res = sendInfo(accountInfo); return res.success; } function initUserAccountInfo(accountInfo) { accountInfo.balance = 0; return accountInfo; } 關於程式實力 我覺得程式的實力可以大致分成兩個部分\n內功：你的思考方式 外功：你的知識 內功好的人不代表外功好，像是你問一個寫程式競賽很厲害的人，甚麼是\u0026quot;OOP\u0026quot;，可能一問三不知\n也有可能你問一個看起來很博學多聞的人，甚麼是\u0026quot;氣泡排序\u0026quot;，他完全不知道怎麼解釋，只說得出來他是拿來排序的\n所以只有內外兼修，相輔相成，才能提升你的程式實力\nbut\n上職場後，看重的又不全是你的程式實力了\n對於一個好的軟體工程師而言：\n實力 = 內功15% + 外功25% + 溝通能力25% + 規劃能力35%\n","date":"2023-02-28T22:23:08+08:00","image":"https://chaoray.github.io/p/%E6%80%8E%E9%BA%BC%E6%A8%A3%E5%AD%B8%E7%A8%8B%E5%BC%8F/title_hu9118eb6b3860f9272d3bb699966fa402_2167154_120x120_fill_box_smart1_3.png","permalink":"https://chaoray.github.io/p/%E6%80%8E%E9%BA%BC%E6%A8%A3%E5%AD%B8%E7%A8%8B%E5%BC%8F/","title":"怎麼樣學程式"},{"content":"在學寫C++的時候，不想用Visual Studio(太肥)，只好拿VSCode來練練手\n這樣的話就要額外裝編譯器了\n想當時裝個MinGW，就不知道如何下手，研究過後寫篇文章幫幫他人\nMSYS2：微軟官方推薦安裝 官網：MSYS2 - Getting Started\n先下載安裝檔，下載位置官網點進去就有，很大很亮眼\n打開後一直點Next即可，當然途中想改安裝位置也沒問題 按Finish後會跳出一個終端機視窗，請注意紅框中的UCRT64 目前MSys2內的Mingw分七種版本：\n名稱 前綴 工具鏈 架構 C 函式庫 C++ 函式庫 MSYS /usr gcc x86_64 cygwin libstdc++ UCRT64 /ucrt64 gcc x86_64 ucrt libstdc++ CLANG64 /clang64 llvm x86_64 ucrt libc++ CLANGARM64 /clangarm64 llvm aarch64 ucrt libc++ CLANG32 /clang32 llvm i686 ucrt libc++ MINGW64 /mingw64 gcc x86_64 msvcrt libstdc++ MINGW32 /mingw64 gcc i686 msvcrt libstdc++ 而MSYS2本身，只能算是一個幫助你建置環境的工具\n那剛剛提到的UCRT又是甚麼?\nUCRT的全名是Universal C Runtime，被Microsoft Visual Studio採用\n主打更好的相容性，用起來跟MSVCRT一樣\nMinGW則採用MSVCRT，Microsoft Visual C++ Runtime，看名字就知道跟微軟有關，可是聽MSYS2官網的介紹是缺點一堆阿\u0026hellip;\n唯一的好處是只要你用Windows系統那就可以直接用，真不錯(?\n原文連結：Environments - MSYS2\n我該安裝哪種? 如果你是在Windows系統上做開發，UCRT64跟MINGW64都可以\n但是我推薦UCRT\n接下來我會分兩種教學\n安裝教學 注意你用的終端機版本 這是UCRT64的 這是MINGW64的 在終端機中打上 UCRT\n1 pacman -S mingw-w64-ucrt-x86_64-gcc MINGW\n1 pacman -S mingw-w64-x86_64-gcc 確認安裝\n1 :: Proceed with installation? [Y/n] \u0026lt;-- 這裡輸入Y(大寫) 等他載完即可，記得確認一下安裝是否正確\n1 gcc --version 正確安裝應該會輸出類似下方的文字\n1 2 3 4 5 # gcc --version gcc.exe (Rev10, Built by MSYS2：2023-02-19 Copyright (C) 2022 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 安裝工具包(可選) UCRT\n1 pacman -S mingw-w64-ucrt-x86_64-toolchain MINGW\n1 pacman -S mingw-w64-x86_64-toolchain 因為是包，所以會跟你確認有哪些要裝\n第一次安裝的大人請直接Enter略過，等之後有經驗了變成小孩再選擇\n1 Enter a selection (default=all): \u0026lt;-- Enter 跑完就ok了~\n重點：加入系統路徑 首先要知道你的MSYS2裝在哪裡\n以剛剛安裝為例，應該是裝在C:\\msys64下\n然後去資料夾內依照你安裝的版本，尋找\\ucrt64或\\mingw64\n以安裝ucrt64為例：\n裡面內有個名為bin的，請將此資料夾路徑複製下來\n1 C:\\msys64\\ucrt64\\bin 然後按Win+R，輸入\n1 rundll32 sysdm.cpl,EditEnvironmentVariables 找到Path後按編輯\n進去之後按新增-\u0026gt;貼上剛剛複製的路徑-\u0026gt;確定\n如果你以上步驟都正確，沒有出現錯誤\n那麼恭喜你，你可以開始學習C/C++之路了\n編譯C\n1 gcc main.c -o main.exe 編譯C++，注意不要跟gcc搞混了，兩個實務上並不能通用\n1 g++ main.cpp -o main.exe MinGW Manager：坊間古早味 直接上Google搜尋vscode 安裝c++，大概會找到MinGW Manager\n它的優點：\n簡單快速 視覺化安裝 缺點：\n版本很舊 對比一下MSYS2跟MinGW Manager的最後更新時間 (截自文章發布)：\nMinGW Manager： 2017-09-06 MSYS2：2023-02-19 差太多了吧！本身很舊以外，裡面的安裝包還是2013年的\n所以不想被時代潮流汰換的話，還是安裝MSYS2會比較好\nMinGW Manager載點：MinGW - Minimalist GNU for Windows\n網路上教學很多，我只介紹一下\n米爾大大教學：[VSCode] Visual Studio Code 執行 C++ (1) - 安裝 VSCode + MinGW\n","date":"2023-02-25T14:16:22+08:00","image":"https://chaoray.github.io/p/%E5%9C%A8windows%E5%AE%89%E8%A3%9Dc/c-compiler/msg-intellisense_hu1da1126b82c3201fcfa749294077f303_65014_120x120_fill_q75_box_smart1.jpg","permalink":"https://chaoray.github.io/p/%E5%9C%A8windows%E5%AE%89%E8%A3%9Dc/c-compiler/","title":"在Windows安裝C/C++ Compiler"},{"content":"從0開始做個dc機器人本來就蠻花時間，而且如果是初學者那更不知道要從哪開始\n所以把過往寫機器人的一些管理技巧整理整理，變成一個模板，不用直接from scratch\n我主要是朝向模組化開發，因為我看很多人在寫bot，都把event、command都塞在main.js裡面\n指令的判斷也是用if...else實作，不好管理還難閱讀\n用require，把每個指令拆成一個檔案，動態載入，刪減也很方便\n1 2 3 +---commands | help.js | ping.js 然後slash command我沒有照一般application commands要註冊，而是在加入伺服器時直接設定\n離開再刪除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // events\\guildCreate.js const { Events, } = require(\u0026#39;discord.js\u0026#39;); module.exports = { name: Events.GuildCreate, async execute(guild) { guild.commands.set(guild.client.slashCommands.map((command) =\u0026gt; command.data)); }, }; // events\\guildDelete.js module.exports = { name: Events.GuildDelete, async execute(guild) { guild.commands.set([]); }, }; Repo連結：Chaoray/DiscordBotTemplate\n","date":"2023-02-05T17:32:11+08:00","image":"https://chaoray.github.io/p/discord-bot-%E6%A8%A1%E6%9D%BF/title_hu9f508b376280e6ea0664b4bd3d37cee9_258059_120x120_fill_box_smart1_3.png","permalink":"https://chaoray.github.io/p/discord-bot-%E6%A8%A1%E6%9D%BF/","title":"Discord Bot 模板"},{"content":"Preface I wondered, what if a class, for example A, has two methods, one that can only be call when A is not a instance, but the other one can only be call when A is an instance.\nPseudo Code\n1 2 3 4 5 6 7 class A; A.do1(); A.do2(); // error a = new A(); a.do1(); // error a.do2(); I looked up for a while on the Internet, and I found there is actually a thing called Static Member.\nWhat is a static member There is only one copy of that member. It is initialized when the program start, even before main starts. It stands for the entire program life. For example\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 using System; public class A { public static int do1() { return 1; } public int do2() { return 2; } } public class Program { public static void Main() { Console.WriteLine(A.do1()); A a = new A(); Console.WriteLine(a.do2()); } } But if I do\n1 2 3 4 5 a.do1(); // Member \u0026#39;A.do1\u0026#39; cannot be accessed with an instance reference; qualify it with a type name instead A.do2(); // An object reference is required for the non-static field, method, or property \u0026#39;A.do2()\u0026#39; This is pretty handy when I need to use something that doesn\u0026rsquo;t belong to the instance.\nHowever, it does belong to the class.\nLike\n1 2 3 4 5 6 7 8 9 class Window { static HWND getActive() { return GetActiveWindow(); } RECT getRect() { return this.rect; } } ActiveWindow is not a part of current window; nevertheless, rect is.\nVery interesting. :D\n","date":"2023-02-04T21:35:56+08:00","permalink":"https://chaoray.github.io/p/oop-static-member/","title":"OOP - Static Member"},{"content":"用管理員開啟cmd後，輸入\n1 bcdedit -set TESTSIGNING OFF 重啟電腦後就消失了~\n","date":"2023-01-20T16:30:19+08:00","permalink":"https://chaoray.github.io/p/%E5%8E%BB%E6%8E%89%E5%95%9F%E7%94%A8windows%E6%B5%AE%E6%B0%B4%E5%8D%B0/","title":"去掉啟用Windows浮水印"},{"content":"Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem Ipsum Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum ultrices nisi a efficitur commodo. Maecenas ornare mauris nec risus finibus, vestibulum fringilla arcu egestas. Maecenas pharetra, libero eu condimentum euismod, velit arcu semper felis, eu porta sapien sem ac mauris. Sed id bibendum ligula, a iaculis nisl. Sed sit amet nulla elementum, auctor odio sagittis, hendrerit nunc. Ut vehicula orci ut leo blandit, vel mattis risus consequat. Ut sit amet ante aliquam, congue metus vel, congue tellus. Suspendisse cursus feugiat quam in euismod. Curabitur eros ligula, scelerisque eu suscipit in, tincidunt quis urna. Integer rutrum porttitor bibendum. Nam commodo pulvinar felis et feugiat. Sed tincidunt luctus ullamcorper.\nDonec odio mi, hendrerit non metus vel, consequat pellentesque nulla. Fusce interdum velit tortor, vitae interdum nulla aliquet vitae. Donec dapibus nulla eu auctor mollis. Fusce rutrum ipsum eget tincidunt gravida. Vivamus faucibus porttitor massa ut sagittis. Pellentesque pulvinar aliquam urna, bibendum auctor dolor auctor ut. Nullam efficitur ac metus vel consectetur. Nunc purus velit, rutrum ut magna euismod, maximus feugiat dolor. Curabitur rhoncus odio nec quam placerat venenatis. Donec tortor dolor, dapibus id leo interdum, mattis dignissim ipsum.\n1 2 3 4 5 6 7 Nulla scelerisque est est, id fermentum tellus feugiat ac. Phasellus pellentesque odio mattis tellus porttitor porttitor. Sed ullamcorper massa eget enim viverra, eget congue augue eleifend. Fusce posuere enim at sagittis blandit. Nullam dapibus lorem quis tortor ultrices lobortis eget quis odio. Pellentesque non urna ultricies, aliquam odio vitae, lacinia odio. Praesent ullamcorper id mauris et posuere. Integer sit amet efficitur ante, non eleifend tortor. Nunc sollicitudin lobortis tempor. In hendrerit sem id massa egestas, tincidunt tincidunt libero tempus. Nulla vitae auctor elit, id auctor ligula. Donec eget porttitor elit. Praesent at facilisis felis, ac consequat quam. Vestibulum consequat, neque eu dictum semper, libero tellus suscipit metus, quis finibus risus quam a nisl. Quisque tempor laoreet odio nec ornare. Nulla facilisi. Morbi eros est, convallis imperdiet urna et, sagittis feugiat ex. Proin laoreet rutrum turpis, eu pretium lorem placerat vestibulum. Praesent a leo odio. Nam sed turpis massa. Sed eu lacus sed nunc bibendum tempor. Sed auctor elementum urna, vitae lacinia nunc tempor at. Nam sed ornare est. Cras ullamcorper eget dui quis convallis. Morbi augue ante, dapibus ut semper sit amet, porta pharetra lacus. Sed est est, dictum sit amet finibus eget, iaculis posuere nunc. Curabitur leo quam, congue eu arcu lobortis, cursus pellentesque tortor. Morbi sit amet commodo odio. Integer eu sem eget odio semper mattis eget eu ante. Integer tempus arcu sed pretium pellentesque. Vestibulum euismod euismod aliquam. Donec pretium sapien et ipsum pharetra, quis suscipit tortor tristique. Aenean arcu libero, efficitur eget accumsan a, volutpat ut metus. Nulla eget auctor nunc, sit amet mollis dui. Aliquam egestas libero non lectus fermentum sollicitudin.\nDonec eget tellus in justo tincidunt consectetur sit amet sed purus.\nVestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia curae; Integer eleifend ultrices congue.\nAenean vulputate nibh quis sodales venenatis. Duis fermentum quam a ante fringilla, sit amet vestibulum diam faucibus. Proin gravida sed urna ac commodo. Phasellus libero massa, lobortis non enim nec, consequat mollis nunc. Fusce fringilla ultricies euismod. Nullam dignissim nulla id est convallis condimentum. Vivamus enim urna, rutrum at nisi ut, ullamcorper malesuada sapien. Integer vestibulum lobortis metus, nec tincidunt tortor pharetra sit amet.\n","date":"2023-01-15T13:43:28+08:00","image":"https://chaoray.github.io/p/lorem-ipsum/title_hua3f7ea6c6c9a6e5d3000e29f1c04374f_385510_120x120_fill_box_smart1_3.png","permalink":"https://chaoray.github.io/p/lorem-ipsum/","title":"Lorem Ipsum"},{"content":"Wanna make the class be able to do a chain-call\n1 2 3 4 5 6 7 8 9 10 11 class TextBox { string text; TextBox addText(const string\u0026amp; append) { text += append; return this; } }; TextBox textBox1; textBox1.addText(\u0026#34;Text1\u0026#34;).addText(\u0026#34;Text2\u0026#34;).addText(\u0026#34;Text3\u0026#34;); This is not going to work :P\n1 2 3 4 5 6 7 8 9 10 11 class TextBox { string text; TextBox\u0026amp; addText(const string\u0026amp; append) { text += append; return *this; } }; TextBox textBox1; textBox1.addText(\u0026#34;Text1\u0026#34;).addText(\u0026#34;Text2\u0026#34;).addText(\u0026#34;Text3\u0026#34;); Works fine!\nOr you can\n1 2 3 4 5 6 7 8 9 10 11 class TextBox { string text; TextBox* addText(const string\u0026amp; append) { text += append; return this; } }; TextBox textBox1; (*(*textBox1.addText(\u0026#34;Text1\u0026#34;)).addText(\u0026#34;Text2\u0026#34;)).addText(\u0026#34;Text3\u0026#34;); Longer, more verbose.\n","date":"2023-01-15T10:44:46+08:00","permalink":"https://chaoray.github.io/p/c-class-return-self/","title":"C++ Class Return Self"}]